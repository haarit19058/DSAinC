#include <iostream>
#include <string>
#include <vector>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <cstdlib>
#include <chrono>

// Headers for process management and resource limits on UNIX-like systems.
// This implementation is POSIX-specific.
#include <sys/resource.h>
#include <sys/wait.h>
#include <unistd.h>
#include <csignal>

namespace fs = std::filesystem;

// ANSI color codes for rich terminal output.
const char* const RESET_COLOR = "\033[0m";
const char* const GREEN_COLOR = "\033[32m";
const char* const RED_COLOR = "\033[31m";
const char* const YELLOW_COLOR = "\033[33m";
const char* const BLUE_COLOR = "\033[34m";
const char* const MAGENTA_COLOR = "\033[35m";

/**
 * @brief Holds all configuration for the test harness.
 */
struct Config {
    std::string source_file;
    std::string test_cases_path;
    std::string binary_name = "solution";
    std::string compiler = "g++";
    std::string cpp_flags = "-std=c++17 -O2 -Wall";
    std::string temp_output_file = "tmp.out";
    std::string compiler_log_file = "compile_errors.log";

    // Resource limits
    int time_limit_seconds = 10;
    rlim_t memory_limit_mb = 1024; // 1 GB
};

/**
 * @brief RAII-based cleanup helper to ensure temporary files are removed.
 */
struct CleanupGuard {
    const Config& cfg;
    ~CleanupGuard() {
        fs::remove(cfg.binary_name);
        fs::remove(cfg.temp_output_file);
        fs::remove(cfg.compiler_log_file);
    }
};


/**
 * @brief Compares two files line by line, ignoring trailing whitespace.
 *
 * @param produced_path The path to the file generated by the user's solution.
 * @param expected_path The path to the file with the correct output.
 * @param diff_details Output string to store details of the first difference found.
 * @return true if files are identical, false otherwise.
 */
bool compare_files(const std::string& produced_path, const std::string& expected_path, std::string& diff_details) {
    std::ifstream f_produced(produced_path), f_expected(expected_path);
    std::string line_produced, line_expected;
    int line_num = 1;

    while (true) {
        bool has_produced = static_cast<bool>(std::getline(f_produced, line_produced));
        bool has_expected = static_cast<bool>(std::getline(f_expected, line_expected));

        if (has_produced) {
            line_produced.erase(line_produced.find_last_not_of(" \n\r\t") + 1);
        }
        if (has_expected) {
            line_expected.erase(line_expected.find_last_not_of(" \n\r\t") + 1);
        }

        if (!has_produced && !has_expected) {
            return true;
        }

        if (line_produced != line_expected) {
            std::ostringstream oss;
            oss << "Difference at Line " << line_num << ":\n"
                << RED_COLOR << "  Expected: `" << line_expected << "`\n"
                << GREEN_COLOR << "  Got:      `" << line_produced << "`" << RESET_COLOR;
            diff_details = oss.str();
            return false;
        }
        line_num++;
    }
}

/**
 * @brief Compiles the source file specified in the configuration.
 *
 * @param cfg The configuration struct.
 * @return true on successful compilation, false otherwise.
 */
bool compile(const Config& cfg) {
    std::cout << BLUE_COLOR << "Compiling " << cfg.source_file << "..." << RESET_COLOR << std::endl;
    std::string command = cfg.compiler + " " + cfg.cpp_flags + " " + cfg.source_file + " -o " + cfg.binary_name + " 2> " + cfg.compiler_log_file;

    int compile_status = system(command.c_str());

    if (compile_status != 0) {
        std::cerr << RED_COLOR << "Compilation failed. Errors logged to " << cfg.compiler_log_file << RESET_COLOR << std::endl;
        std::ifstream error_file(cfg.compiler_log_file);
        if (error_file) {
            std::stringstream buffer;
            buffer << error_file.rdbuf();
            std::cerr << buffer.str() << std::endl;
        }
        return false;
    }

    std::cout << GREEN_COLOR << "Compilation successful." << RESET_COLOR << std::endl;
    return true;
}

/**
 * @brief Executes the user's solution in a sandboxed child process with resource limits.
 *
 * This function uses fork() to create a child process. The child process then
 * sets resource limits on itself before using exec() to run the user's code.
 * The parent process waits for the child and analyzes its exit status.
 *
 * @param in_path Path to the input file.
 * @param cfg The configuration struct.
 * @param passed_count Reference to the count of passed tests.
 */
void run_test_case(const fs::path& in_path, const Config& cfg, int& passed_count) {
    std::string base_name = in_path.stem().string();
    fs::path expected_out_path = in_path;
    expected_out_path.replace_extension(".out");

    std::cout << YELLOW_COLOR << "Running test: " << std::setw(15) << std::left << base_name << RESET_COLOR << " ... ";
    
    if (!fs::exists(expected_out_path)) {
        std::cout << MAGENTA_COLOR << "SKIPPED" << RESET_COLOR << " (Missing .out file)" << std::endl;
        return;
    }
    
    pid_t pid = fork();

    if (pid == -1) {
        std::cerr << RED_COLOR << "FATAL: fork() failed." << RESET_COLOR << std::endl;
        return;
    }

    if (pid == 0) { // Child process
        // 1. Redirect stdin and stdout
        if (!freopen(in_path.c_str(), "r", stdin) || !freopen(cfg.temp_output_file.c_str(), "w", stdout)) {
             perror("freopen");
             exit(127); // Use a distinct exit code for setup failure
        }
        
        // 2. Set resource limits
        struct rlimit time_limit, mem_limit;
        
        // Time limit (CPU time)
        time_limit.rlim_cur = cfg.time_limit_seconds;
        time_limit.rlim_max = cfg.time_limit_seconds + 1; // A grace period for the hard limit
        if (setrlimit(RLIMIT_CPU, &time_limit) != 0) {
            perror("setrlimit(RLIMIT_CPU)");
            exit(127);
        }
        
        // Memory limit (virtual memory)
        mem_limit.rlim_cur = cfg.memory_limit_mb * 1024 * 1024;
        mem_limit.rlim_max = cfg.memory_limit_mb * 1024 * 1024;
        if (setrlimit(RLIMIT_AS, &mem_limit) != 0) {
            perror("setrlimit(RLIMIT_AS)");
            exit(127);
        }

        // 3. Execute the user's program
        execl(("./" + cfg.binary_name).c_str(), cfg.binary_name.c_str(), nullptr);
        
        // If execl returns, it must have failed.
        perror("execl");
        exit(127);

    } else { // Parent process
        int status;
        waitpid(pid, &status, 0);

        if (WIFEXITED(status)) {
            int exit_code = WEXITSTATUS(status);
            if (exit_code == 0) {
                // Normal exit, compare files
                std::string diff_details;
                if (compare_files(cfg.temp_output_file, expected_out_path.string(), diff_details)) {
                    std::cout << GREEN_COLOR << "PASS" << RESET_COLOR << std::endl;
                    passed_count++;
                } else {
                    std::cout << RED_COLOR << "FAIL" << RESET_COLOR << std::endl;
                    std::cout << diff_details << std::endl;
                }
            } else {
                std::cout << RED_COLOR << "RE" << RESET_COLOR << " (Runtime Error, Exit Code: " << exit_code << ")" << std::endl;
            }
        } else if (WIFSIGNALED(status)) {
            int term_signal = WTERMSIG(status);
            if (term_signal == SIGXCPU) {
                std::cout << RED_COLOR << "TLE" << RESET_COLOR << " (Time Limit Exceeded)" << std::endl;
            } else if (term_signal == SIGSEGV || term_signal == SIGABRT) {
                std::cout << RED_COLOR << "MLE" << RESET_COLOR << " (Memory Limit Exceeded or Segfault)" << std::endl;
            } else {
                std::cout << RED_COLOR << "RE" << RESET_COLOR << " (Runtime Error, Terminated by Signal: " << term_signal << ")" << std::endl;
            }
        }
    }
}


int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <source_file.cpp> [test_cases_directory]" << std::endl;
        return 1;
    }

    Config cfg;
    cfg.source_file = argv[1];

    if (argc >= 3) {
        cfg.test_cases_path = argv[2];
    } else {
        // A default path can be useful, but inform the user.
        cfg.test_cases_path = "/home/haarit/testCasesCP";
        std::cout << YELLOW_COLOR << "No test case directory provided. Using default: " 
                  << cfg.test_cases_path << RESET_COLOR << std::endl;
    }

    if (!fs::exists(cfg.source_file)) {
        std::cerr << RED_COLOR << "Error: Source file not found: " << cfg.source_file << RESET_COLOR << std::endl;
        return 1;
    }

    if (!fs::is_directory(cfg.test_cases_path)) {
        std::cerr << RED_COLOR << "Error: Test cases directory not found: " << cfg.test_cases_path << RESET_COLOR << std::endl;
        return 1;
    }

    // RAII guard to ensure cleanup happens on all exit paths.
    CleanupGuard cleanup_guard{cfg};

    if (!compile(cfg)) {
        return 1;
    }

    std::vector<fs::path> test_files;
    for (const auto& entry : fs::directory_iterator(cfg.test_cases_path)) {
        if (entry.path().extension() == ".in") {
            test_files.push_back(entry.path());
        }
    }
    
    std::sort(test_files.begin(), test_files.end(), [](const fs::path& a, const fs::path& b){
        std::string s_a = a.stem().string();
        std::string s_b = b.stem().string();
        try {
            // Try numeric sort
            return std::stoi(s_a) < std::stoi(s_b);
        } catch(const std::invalid_argument&) {
            // Fallback to lexicographical sort
            return s_a < s_b;
        }
    });
    
    int passed_count = 0;
    int total_tests = test_files.size();
    
    if (total_tests == 0) {
        std::cout << YELLOW_COLOR << "No '.in' files found in the test directory." << RESET_COLOR << std::endl;
    }

    for (const auto& in_path : test_files) {
        run_test_case(in_path, cfg, passed_count);
    }

    std::cout << "\n" << BLUE_COLOR << "------ Summary ------" << RESET_COLOR << std::endl;
    double percentage = (total_tests > 0) ? (static_cast<double>(passed_count) / total_tests) * 100.0 : 0.0;
    std::cout << "Tests Passed: " << (passed_count == total_tests ? GREEN_COLOR : RED_COLOR)
              << passed_count << " / " << total_tests << RESET_COLOR 
              << " (" << std::fixed << std::setprecision(2) << percentage << "%)" << std::endl;
    std::cout << BLUE_COLOR << "---------------------" << RESET_COLOR << std::endl;

    return (passed_count == total_tests) ? 0 : 1;
}
